# Архитектура конвейера с пересекающимися очередями

## Описание задачи

Реализован конвейер из двух пересекающихся очередей A и B, содержащих простые числа. 
Узлы пересечения принадлежат обеим очередям и сдвигаются по той очереди, в которую проталкивается новое число.

## Архитектура решения

### Основные компоненты

1. **ConveyorNode** - узел конвейера
   - Хранит значение (простое число)
   - Знает свою позицию и тип (только A, только B, или пересечение)
   - Иммутабельная позиция и тип, мутабельное значение

2. **IntersectionPoint** - точка пересечения
   - Value Object для описания пересечения
   - Содержит позиции в обеих очередях
   - Валидация на этапе создания

3. **ConveyorConfig** - конфигурация конвейера
   - Builder pattern для удобного создания
   - Валидация конфигурации (длины очередей, корректность пересечений)
   - Иммутабельная после создания

4. **Conveyor** - основной класс конвейера
   - Методы `pushA(int)` и `pushB(int)` для проталкивания чисел
   - Валидация простых чисел
   - Управление общими узлами пересечения

### Принятые решения

#### Использование ArrayList
- **Почему**: O(1) доступ по индексу, что критично для работы с позициями узлов
- **Альтернативы**: LinkedList (O(n) доступ), кольцевой буфер (сложнее управление пересечениями)

#### Общие узлы для пересечений
- **Как**: Один объект ConveyorNode разделяется между двумя очередями
- **Преимущество**: Гарантия синхронизации значений в точках пересечения
- **Реализация**: HashMap с ключом-композитом из позиций в обеих очередях

#### Валидация простых чисел
- Проверка на этапе `pushA`/`pushB`
- Алгоритм: пробное деление до √n с оптимизацией для четных чисел
- O(√n) сложность

#### Builder Pattern для конфигурации
- Гибкое создание конфигурации с валидацией
- Иммутабельность после построения
- Читаемый и maintainable код

### Сложность операций

- **pushA/pushB**: O(n), где n - длина очереди (сдвиг всех элементов)
- **Проверка простоты**: O(√m), где m - проверяемое число
- **Инициализация**: O(n + k), где k - количество пересечений

### Гарантии и инварианты

1. Узлы пересечения всегда содержат одно и то же значение в обеих очередях
2. В очередь можно добавлять только простые числа
3. Конфигурация валидна: пересечения в пределах длин очередей
4. FIFO-семантика: новое значение в начало, старое из конца

## Тестовое покрытие

- Базовые операции: push в очереди A и B, выталкивание при заполнении
- Пересечения: обновление при push в A и B, множественные пересечения
- Валидация: отклонение непростых чисел, валидация конфигурации
- Граничные случаи: минимальные очереди, пересечения на границах, переполнение

Всего: 26 тестов, покрывающих все ключевые сценарии

## Запуск

```bash
# Сборка и тесты
./gradlew build test

# Запуск демонстрации
./gradlew run
```

